model DVFFEVRP

!options explterm
!options noimplicit

uses "mmxprs";

parameters
	DataFile = 'examples/example1.txt';
end-parameters

declarations
	print : boolean;
end-declarations

print := false;

(! ### Start of initialization of set sizes ### !)
declarations
	numVisits     : integer; ! Max number of visits for all Nodes
	numPNodes     :	integer; ! Number of parking Nodes
	numCNodes     :	integer; ! Number of charging Nodes
	numANodes     :	integer; ! Number of artificial Nodes
	numRNodes     :	integer; ! Number of real Nodes
	numNodes      :	integer; ! Total number of Nodes
	numROperators : integer; ! Number of real operators
	numAOperators : integer; ! Number of artificial operators
end-declarations

initializations from DataFile
	numVisits;
	numPNodes;
	numCNodes;
	numROperators;
	numAOperators;
end-initializations

numRNodes := numCNodes + numPNodes;
numANodes := numROperators * 2;
numNodes  := numRNodes + numANodes;
! ### End of initialization of set sizes ### !


! ### Start of declaration of sets ### !
declarations
	Nodes      : set of integer; ! Set of all Nodes
	pNodes     : set of integer; ! Set of all parking Nodes. A subset of Nodes.
	cNodes     : set of integer; ! Set of all charging Nodes. A subset of Nodes.
	rNodes     : set of integer; ! Set of all real Nodes. A subset of Nodes.
	aNodes     : set of integer; ! Set of all artificial Nodes. A subset of Nodes.
	aOriginNodes : set of integer;
	aDestinationNodes : set of integer;
	rOperators : set of integer; ! Set of all real operators.
	aOperators : set of integer; ! Set of all artificial operators
	visits     : set of integer; ! Set of all possible visits
end-declarations

initializations from DataFile
	numVisits;
	numPNodes;
	numCNodes;
	numROperators;
	numAOperators;
end-initializations

visits := 1..numVisits;

! Initialize all node sets ! 
pNodes    := 1 .. numPNodes;
cNodes    := (numPNodes + 1) .. numRNodes;
rNodes    := pNodes + cNodes;
aOriginNodes := (numRNodes + 1) .. (numRNodes + numROperators)
aDestinationNodes := (1+ numRNodes + numROperators) .. (numRNodes + numANodes);
aNodes    := aOriginNodes + aDestinationNodes;
Nodes     := rNodes + aNodes;

! Initialize all operator sets !
rOperators := 1 .. numROperators;
aOperators := 1 .. numAOperators;

! ### End of initialization of sets ### !

if print then
	writeln('------ Counts ------');
	writeln('Total number of Nodes:          ', numNodes);
	writeln('Number of real Nodes:           ', numRNodes);
	writeln('Number of parking Nodes:        ', numPNodes);
	writeln('Number of charging Nodes:       ', numCNodes);
	writeln('Number of artificial Nodes:     ', numANodes);
	writeln('Number of operators:            ', numROperators);
	writeln('Number of artificial operators: ', numAOperators);
	writeln('Number of visits:               ', numVisits);
	
	writeln('');
	writeln('------ Sets ------');
	writeln('All Nodes:            ', Nodes);
	writeln('Real Nodes:           ', rNodes);
	writeln('Parking Nodes:        ', pNodes);
	writeln('Charging Nodes:       ', cNodes);
	writeln('Artificial Nodes:     ', aNodes);
	writeln('Artificial destinations: ', aDestinationNodes);
	writeln('Artificial origin: ', aOriginNodes);
	writeln('Operators:            ', rOperators);
	writeln('Artificial operators: ', aOperators);
	writeln('Visits:               ', visits);
	writeln('');
end-if


! ### Start of declaration of Parameters ### !
declarations
	! Nodes !
	originNodeROperator       : array(rOperators) of integer; ! Origin Nodes for all real operators
	destinationNodeROperator  : array(rOperators)  of integer; ! Artificial destination node of real operators
	startNodeROperator        : array(rOperators) of integer; ! Actual start node for real operators
	chargingNodeAOperator     : array(aOperators) of integer; ! Origin Nodes for all artificial operators
	parkingNodeAOperator      : array(aOperators) of integer; ! Actual start node for artificial operator
	
	
	chargingSlotsAvailable    : array(cNodes)     of integer; ! Available charging slots at charging Nodes
	
	! Costs !
	costOfDeviation         : real;
	costOfPostponedCharging : real;
	
	! Times !
	travelTimeVehicle    : array(rNodes,rNodes) of real;
	travelTimeBike       : array(rNodes,rNodes) of real;
	handlingTimeP        : real;
	handlingTimeC        : real;
	timeLimit            : real;
	
	! Initial state !
	travelTimeToOriginR  : array(rOperators) of real;
	travelTimeToParkingA : array(aOperators) of real;
	initialHandling      : array(rOperators) of integer;
	initialRegularInP    : array(pNodes)     of integer;
	initialInNeedP       : array(pNodes)     of integer;
	finishedDuringC      : array(cNodes)     of integer;
	idealStateP          : array(pNodes)     of integer;
end-declarations

initializations from DataFile
	originNodeROperator;
	destinationNodeROperator;
	startNodeROperator;
	chargingNodeAOperator;
	parkingNodeAOperator;
	chargingSlotsAvailable;
	costOfDeviation;
	costOfPostponedCharging;
	travelTimeVehicle;
	travelTimeBike;
	handlingTimeP;
	handlingTimeC;
	timeLimit;
	travelTimeToOriginR;
	travelTimeToParkingA;
	initialHandling;
	initialRegularInP;
	initialInNeedP;
	finishedDuringC;
	idealStateP;
end-initializations
! ### End of initialization of Parameters ### !

if print then
	writeln('------ Parameters ------');
	writeln('Origin Nodes for real operators:                                         ', originNodeROperator);
	writeln('Destination Nodes for real operators:                                    ', destinationNodeROperator);
	writeln('Actual starting node for real operators:                                 ', startNodeROperator);
	writeln('Origin Nodes for real operators:                                         ',originNodeROperator);
	writeln('Destination Nodes for real operators:                                    ',destinationNodeROperator);
	writeln('Actual starting node for real operators:                                 ',startNodeROperator);
	writeln('Charging Nodes for artificial operators:                                 ',chargingNodeAOperator);
	writeln('Parking Nodes for artificial operators:                                  ',parkingNodeAOperator);
	writeln('Available slots at charging stations:                                    ',chargingSlotsAvailable);
	writeln('Cost per vehicle deviation in each node:                                 ',costOfDeviation);
	writeln('Cost per vehicle of postponing chargning:                                ',costOfPostponedCharging);
	writeln('Travel times between real Nodes using vehicle:                           ',travelTimeVehicle);
	writeln('Travel times between real Nodes using bikes:                             ',travelTimeBike);
	writeln('Time to park a car:                                                      ',handlingTimeP);
	writeln('Time to handle a car:                                                    ',handlingTimeC);
	writeln('Time limit for planning period:                                          ',timeLimit);
	writeln('Remaining travel time to origin node for real operators:                 ',travelTimeToOriginR);
	writeln('Remaining travel time to parking node for artificial operators:          ',travelTimeToParkingA);
	writeln('Initial handling for real operators:                                     ',initialHandling);
	writeln('Initial number of parked cars in each parking node:                      ',initialRegularInP);
	writeln('Initial number of cars in a parking node in need of charging:            ',initialInNeedP);
	writeln('Number of cars that will finish charging in a charging node:             ',finishedDuringC);
	writeln('Ideal number of parked cars in each node at the end for planning period: ',idealStateP);
end-if



! ### Start of declaration of Variables ### !
declarations
	x      : dynamic array(Nodes, visits, Nodes, visits, rOperators)  of mpvar;
	h      : dynamic array(Nodes, visits, Nodes, visits, rOperators)  of mpvar;
	hA     : dynamic array(cNodes, visits, pNodes, visits, aOperators)of mpvar;
	c      : dynamic array(cNodes, visits, rOperators)                of mpvar;
	q      : dynamic array(rNodes, visits, rOperators)                of mpvar;
	t      : dynamic array(Nodes, visits)                             of mpvar;
	s      : dynamic array(Nodes, visits)                             of mpvar;
	sC     : dynamic array(pNodes, visits)                            of mpvar;
	sPlus  : dynamic array(pNodes)                                    of mpvar;
	sMinus : dynamic array(pNodes)                                    of mpvar;
end-declarations


forall(pp in rOperators) do
	forall (ii in Nodes - aNodes + {originNodeROperator(pp)}) do
		if ii = originNodeROperator(pp) then
			forall(nn in visits) do
				create(x(ii, 1, startNodeROperator(pp), nn, pp));
			end-do
		else	
			forall(jj in Nodes - aNodes + {destinationNodeROperator(pp)} | jj <> ii) do
				forall(mm in visits, nn in visits) do
					create(x(ii, mm, jj, nn, pp));
					x(ii, mm, jj, nn, pp) is_binary;
				end-do
			end-do
		end-if
	end-do
end-do

forall(pp in rOperators) do
	forall (ii in Nodes - aNodes + {originNodeROperator(pp)} - cNodes) do
		if ii = originNodeROperator(pp) then
			forall(nn in visits) do
				create(h(ii, 1, startNodeROperator(pp), nn, pp));
			end-do
		else	
			forall(jj in Nodes - aNodes + {destinationNodeROperator(pp)} | jj <> ii) do
				forall(mm in visits, nn in visits) do
					create(h(ii, mm, jj, nn, pp));
					h(ii, mm, jj, nn, pp) is_binary;
				end-do
			end-do
		end-if
	end-do
end-do

forall(pp in aOperators, mm in visits, nn in visits) do
	create(hA(chargingNodeAOperator(pp), mm, parkingNodeAOperator(pp), nn, pp));
	hA(chargingNodeAOperator(pp), mm, parkingNodeAOperator(pp), nn, pp) is_binary;
end-do

forall(jj in cNodes, mm in visits, pp in rOperators) do
	create(c(jj, mm, pp));
	c(jj, mm, pp) is_binary;
end-do

forall(jj in rNodes, mm in visits, pp in rOperators) do
	create(q(jj, mm, pp));
	q(jj, mm, pp) is_binary;
end-do

forall(ii in Nodes, mm in visits) do
	create(t(ii, mm));
	create(s(ii, mm));
	t(ii, mm) is_semcont 0;
	s(ii, mm) is_semint 0;
end-do

forall(ii in pNodes, mm in visits) do
	create(sC(ii, mm));
	sC(ii, mm) is_semint 0;
end-do

forall(ii in pNodes) do 
	create(sPlus(ii));
	create(sMinus(ii));
	sPlus(ii) is_semint 0;
	sMinus(ii) is_semint 0;
end-do

! ### End of declaration of Variables ### !


! ### Start of declaration of objective ### !
declarations
		Objective: linctr;
end-declarations

(!
Objective :=  costOfDeviation * sum(ii in pNodes) sMinus(ii) + 
			  costOfPostponedCharging * sum(ii in pNodes) sC(ii, numVisits);
!)

Objective := + (sum (ii in Nodes, mm in visits, jj in Nodes, nn in visits) (x(ii,mm,jj,nn,1) + x(ii,mm,jj,nn,2)));

! ### End of declaration of objective ### !			 
		

! ### Start of declaration of routing constraints ### !		
declarations
	operatorStart: dynamic array(rOperators)                 of linctr;
	operatorEnd  : dynamic array(rOperators)                 of linctr;
	inEqualsOut  : dynamic array(rOperators, rNodes, visits) of linctr;
	maxVisitIn   : dynamic array(rNodes, visits)             of linctr;
	maxVisitOut  : dynamic array(rNodes, visits)             of linctr;
end-declarations 

forall(pp in rOperators) do
	operatorStart(pp) := sum(nn in visits) x(originNodeROperator(pp), 1, startNodeROperator(pp), nn, pp) = 1;
end-do

forall(pp in rOperators) do
	operatorEnd(pp) := sum(ii in Nodes, mm in visits | ii <>  destinationNodeROperator(pp)) x(ii, mm, destinationNodeROperator(pp), 1, pp) = 1;
end-do

forall(pp in rOperators, ii in rNodes, mm in visits) do
	inEqualsOut(pp, ii, mm) := sum(jj in Nodes, nn in visits | jj <> originNodeROperator(pp)) x(ii, mm, jj, nn, pp) =
				               sum(jj in Nodes, nn in visits | jj <> destinationNodeROperator(pp)) x(jj, nn, ii, mm, pp);
end-do

forall(ii in rNodes, mm in visits) do
	maxVisitIn(ii, mm) := sum(pp in rOperators, jj in Nodes - aOriginNodes, nn in visits) x(ii, mm, jj, nn, pp) <= 1;
end-do

forall(ii in rNodes, mm in visits) do
	maxVisitOut(ii, mm) := sum(pp in rOperators, jj in Nodes - aDestinationNodes, nn in visits) x(jj, nn, ii, mm, pp) <= 1;
end-do
! ### End of declaration of routing constraints ### !	

! ### Start of declaration of time constraints ### !
declarations
	travelTimeCharging : dynamic array(rOperators, cNodes, visits, rNodes, visits) of linctr;
	travelTimeParking  : dynamic array(rOperators, pNodes, visits, rNodes, visits) of linctr;
	startTime : dynamic array(rOperators, visits) of linctr;
	travelFlow : dynamic array(Nodes, visits - {numVisits}) of linctr;
	endTime : dynamic array(rOperators) of linctr;
end-declarations 

forall(pp in rOperators, ii in cNodes, mm in visits, jj in rNodes, nn in visits) do
	travelTimeCharging(pp, ii, mm, jj, nn) := t(ii, mm) + travelTimeBike(ii,jj) <= t(jj,nn) + timeLimit*(1 - x(ii,mm,jj,nn,pp));
end-do

forall(pp in rOperators, ii in pNodes, mm in visits, jj in rNodes, nn in visits) do
	travelTimeParking(pp, ii, mm, jj, nn) := t(ii, mm) + travelTimeBike(ii,jj) <= t(jj,nn) + timeLimit*(1 - x(ii,mm,jj,nn,pp));
end-do

forall(pp in rOperators, mm in visits) do
	startTime(pp, mm) := t(startNodeROperator(pp), mm) >= travelTimeToOriginR(pp)*x(originNodeROperator(pp), 1, startNodeROperator(pp), mm, pp);
end-do

forall(ii in Nodes, mm in visits - {numVisits}) do
	travelFlow(ii, mm) := t(ii,mm) <= t(ii,mm+1);
end-do

forall(pp in rOperators) do
	endTime(pp) := t(destinationNodeROperator(pp), numVisits) <= timeLimit;
end-do

! ### End of declaration of time constraints ### !
	

! ### Start of declaration of handling constraints ### !
declarations
	handleOnlyIfX : dynamic array(Nodes, visits, rNodes, rOperators) of linctr;
end-declarations 
! ### End of declaration of handling constraints ### !		 
minimize(Objective);
writeln('Objective function value: ', getobjval);


! ### Variables used for printing ### !
declarations
	currNode : integer;
	currLowest : integer;
	currVisit: integer;
	currLowestNode : integer;
	foundX : boolean;
	lastVisit : array(Nodes) of integer;
end-declarations

forall(pp in rOperators) do
	currNode := originNodeROperator(pp);
	currVisit := 1;
	foundX := true;
	
	forall(ii in Nodes) do
		lastVisit(ii) := 0;
	end-do
	write('Route of operator ', pp, ': ');
	write(currNode, ' (t: 0, h: ', initialHandling(pp), ') -> ');
	
	while(foundX) do
		lowest := numVisits+1;
		foundX := false;
		if currNode <> destinationNodeROperator(pp) then
			forall(jj in Nodes - aNodes + {destinationNodeROperator(pp)}, nn in visits) do
				if getsol(x(currNode, currVisit, jj, nn, pp)) = 1 then
					if (nn > lastVisit(jj) and nn < lowest) then
						foundX := true;
						lowest := nn;
						currLowestNode := jj;
					end-if
				end-if
			end-do
			
			if foundX then
				write(currLowestNode);
				write('(t: ', getsol(t(currLowestNode, lowest)), ', ');
				test := false;
				forall(nn in cNodes) do
					if nn = currNode then
						test := true
					end-if
				end-do
				
				if test then
					write('h: 0)');
				else
					write('h: ', getsol(h(currNode, currVisit, currLowestNode, lowest, pp)),')');
				end-if
				write(' -> ');
				lastVisit(currNode) := lowest;
				currNode := currLowestNode;
				currVisit := lowest;
			end-if
		else
			write(currNode);	
		end-if
	end-do
	writeln('');
end-do

writeln('');
forall(ii in Nodes, nn in visits, mm in visits, jj in Nodes) do
	if getsol(x(ii, nn, jj, mm, 1)) = 1 then
		writeln("Going from: ", ii, " on visit: ", nn, " to node: ", jj, " on visit: ", mm);
	end-if
end-do
writeln('');
forall(ii in Nodes, nn in visits, mm in visits, jj in Nodes) do
	if getsol(x(ii, nn, jj, mm, 2)) = 1 then
		writeln("Going from: ", ii, " on visit: ", nn, " to node: ", jj, " on visit: ", mm);
	end-if
end-do

!fclose(F_OUTPUT);!)
end-model


